## Readout Environment based on Quantum Langevin Equation simulation of
## readout resonator photon dynamics
## Constructed only for a Single Evaluation
## And then vmapped appropriately

# Imports for Gymnax Environment
from envs.environment_template import SingleStepEnvironment
from gymnax.environments.environment import EnvParams

# Standard Imports
import jax
import jax.numpy as jnp
from jax import lax, config, vmap, jit
from jax.scipy.special import erf
from jax.scipy.integrate import trapezoid
from jax.nn import relu
from jax.numpy.fft import fft, fftfreq, ifft, fftshift
from gymnax.environments import spaces
from typing import Tuple, Optional
import chex
from flax import struct

import matplotlib.pyplot as plt

# Imports specific to ODE Simulator
from diffrax import (
    diffeqsolve,
    Tsit5,
    LinearInterpolation,
    ODETerm,
    SaveAt,
    PIDController,
)
import distrax

config.update("jax_enable_x64", True)


@struct.dataclass
class EnvState:
    """
    Flax Dataclass used to store Dynamic Environment State
    All relevant params that get updated each step should be stored here
    """

    reward: float
    max_pf: float
    max_photon: float
    photon_time: float
    smoothness: float
    bandwidth: float
    pulse_reset_val: float
    action: chex.Array
    timestep: int


@struct.dataclass
class EnvParams:
    """
    Flax Dataclass used to store Static Environment Params
    All static env params should be kept here, though they can be equally kept
    in the Jax class as well
    """

    args: chex.Array
    t1: float
    ideal_photon: float

    window_length: Optional[int] = 15
    kernel: Optional[chex.Array] = jnp.ones(window_length) / window_length
    gauss_mean: Optional[int] = 0.0
    gauss_std: Optional[int] = 1.0
    small_window: Optional[chex.Array] = jnp.linspace(
        -0.5 * (window_length - 1), 0.5 * (window_length - 1), window_length
    )
    gauss_kernel: Optional[chex.Array] = (
        1
        / (jnp.sqrt(2 * jnp.pi) * gauss_std)
        * jnp.exp(-((small_window - gauss_mean) ** 2) / (2 * gauss_std**2))
    )
    dirac_delta_kernel: Optional[chex.Array] = jnp.ones(1)

    photon_penalty: Optional[float] = 50.0
    bandwidth_penalty: Optional[float] = 5.0
    smoothness_penalty: Optional[float] = 2.0
    bandwidth_scale: Optional[float] = 5.0
    time_penalty: Optional[float] = 50.0

    bandwidth_threshold: Optional[float] = 0.05
    smoothness_threshold: Optional[float] = 1.5

    t0: Optional[float] = 0.0

    num_actions: Optional[int] = 121
    num_sim: Optional[int] = 361

    min_action: Optional[float] = -1.0
    max_action: Optional[float] = 1.0

    min_reward: Optional[float] = -1000.0
    max_reward: Optional[float] = 10.0

    min_separation: Optional[float] = 0.0
    max_separation: Optional[float] = 15.0

    min_bandwidth: Optional[float] = 0.0
    max_bandwidth: Optional[float] = 2.0 * bandwidth_scale

    min_photon: Optional[float] = 0.0
    max_photon: Optional[float] = 50.0

    min_smoothness: Optional[float] = 0.0
    max_smoothness: Optional[float] = 20.0

    dt0: Optional[float] = 1e-3
    max_steps: Optional[int] = 4096
    solver: Optional[Tsit5] = Tsit5()

    # Real and Imaginary Components of Ground and Excited Resonator Coherent State
    y0 = jnp.array([0.0, 0.0, 0.0, 0.0], dtype=jnp.float64)


class SinglePhotonLangevinReadoutEnv(SingleStepEnvironment):
    """
    Jax Compatible environment for finding the optimal Readout Pulse to be played on a Readout Resonator.
    The Action Space consists of a n_actions long, real-valued pulse that in each episode is generated by
    the RL Agent in a single step. There are no observations for this environment, only a fixed 0 output.
    """

    def __init__(
        self,
        kappa: float,
        chi: float,
        kerr: Optional[float] = 0.002,
        time_coeff: Optional[float] = 10.0,
        snr_coeff: Optional[float] = 10.0,
        smoothness_coeff: Optional[float] = 10.0,
        smoothness_baseline_scale: Optional[float] = 1.0,
        gauss_kernel_len: Optional[int] = 15,
        gauss_kernel_std: Optional[float] = 2.0,
        bandwidth: Optional[float] = 50.0,
        freq_relative_cutoff: Optional[float] = 0.001,
        bandwidth_coeff: Optional[float] = 10.0,
        n0: Optional[float] = 30.0,
        tau_0: Optional[float] = 0.398,
        res_amp_scaling: Optional[float] = 2.3,
        nR: Optional[float] = 0.05,
        snr_scale_factor: Optional[float] = 10.0,
        gamma_I: Optional[float] = 1 / 26,
        photon_gamma: Optional[float] = 1 / 300,
        num_t1: Optional[float] = 8.0,
        init_fid: Optional[float] = 1.0 - 1e-3,
        photon_weight: Optional[float] = 1.0,
        standard_fid: Optional[float] = 0.99,
        shot_noise_std: Optional[float] = 0.005,
    ):
        super().__init__()
        self._kappa = kappa
        self._tau = 1 / kappa
        self._chi = chi
        self._kerr = kerr
        self._init_fid = init_fid
        self._t1 = num_t1 * self._tau
        self._ideal_photon = nR
        self._photon_gamma = photon_gamma
        self._gamma_I = gamma_I
        self.ts_sim = jnp.linspace(0.0, self._t1, 361, dtype=jnp.float64)
        self.ts_action = jnp.linspace(0.0, self._t1, 121, dtype=jnp.float64)
        self.float_dtype = jnp.float32
        self.complex_dtype = jnp.complex64
        self.saveat = SaveAt(ts=self.ts_sim)
        self.stepsize_controller = PIDController(
            rtol=1e-3,
            atol=1e-5,
            pcoeff=0.4,
            icoeff=0.3,
            dcoeff=0.0,
            jump_ts=self.ts_action,
        )
        self.a0 = 0.5 * jnp.sqrt(n0 * (self._kappa**2 + self._chi**2))
        self._two_kappa_index = int(0.2 * (len(self.ts_sim) - 1))
        self.photon_uncertainty = 0.5
        self.mu = res_amp_scaling
        self.min_acq_time = 0.032
        self.gauss_kernel_len = 15  # For default gaussian smoothing
        self.gauss_kernel_std = 2.0  # For default gaussian smoothing
        params = self.default_params

        self.bandwidth = bandwidth

        self.precompile()
        self.kernel = params.gauss_kernel
        self.photon_limit = self.determine_max_photon()
        self.baseline_smoothness = self.get_baseline_smoothness()

        self.gauss_kernel_len = gauss_kernel_len
        self.gauss_kernel_std = gauss_kernel_std

        self.freqs_shifted = jnp.fft.fftshift(
            jnp.fft.fftfreq(n=len(self.ts_action), d=self._t1 / len(self.ts_action))
            * self._tau
        )
        self.scaling_factor = snr_scale_factor
        self.ind = 50
        self.pF_factor = snr_coeff
        self.time_factor = time_coeff
        self.smoothness_factor = smoothness_coeff
        self.bandwidth_factor = bandwidth_coeff
        self.freq_relative_cutoff = freq_relative_cutoff
        self.photon_penalty = 100.0
        self.order_penalty = 100.0
        self.amp_penalty = 50.0
        self.actual_max_photons = n0 * (
            1.0
            - 2.0 * jnp.exp(-0.5 * kappa * tau_0) * jnp.cos(0.5 * chi * tau_0)
            + jnp.exp(-kappa * tau_0)
        )
        self.photon_weight = photon_weight
        self.dt = self._t1 / len(self.ts_sim - 1)

        self.smoothness_baseline_scale = smoothness_baseline_scale
        self.standard_fid = standard_fid
        self.shot_noise_std = shot_noise_std
        self.tau_0 = tau_0

    @property
    def default_params(self) -> EnvParams:
        """
        IMPORTANT Retrieving the Default Env Params
        """
        return EnvParams(
            args=jnp.array(
                [0.5 * self._kappa, self._chi, self._kerr],
                dtype=self.float_dtype,
            ),
            t1=self._t1,
            ideal_photon=self._ideal_photon,
            min_action=-self.mu,
            max_action=self.mu,
            window_length=self.gauss_kernel_len,
            gauss_std=self.gauss_kernel_std,
        )

    def determine_max_photon(self):
        """Physics Specific Function"""
        real_action = jnp.ones_like(self.ts_action, dtype=jnp.float64)
        res_drive = self.a0 * real_action
        res_drive = self.drive_smoother(res_drive)
        results = self.calc_results(res_drive)
        results_g = results[:, 0] + 1.0j * results[:, 1]
        max_photon = jnp.max(jnp.abs(results_g) ** 2)
        return max_photon

    def t1(self):
        """Physics Specific Function"""
        return -2 / self._kappa * jnp.log(1.0 - 1 / self.mu)

    def t3(self):
        """Physics Specific Function"""
        return -2 / self._kappa * jnp.log(self.mu / (1.0 + self.mu))

    def dummy_a3r_waveform(
        self,
        t1: Optional[float] = None,
        t2: Optional[float] = None,
        t3: Optional[float] = None,
    ):
        """Physics Specific Function"""
        if t1 is None:
            t1 = self.t1()
        if t2 is None:
            t2 = 0.25
        if t3 is None:
            t3 = self.t3()
        signal = jnp.heaviside(t1 - self.ts_action, 0.0)
        signal += (
            1
            / self.mu
            * (
                jnp.heaviside(t2 - self.ts_action, 0.0)
                - jnp.heaviside(t1 - self.ts_action, 0.0)
            )
        )
        signal -= jnp.heaviside(t2 + t3 - self.ts_action, 0.0) - jnp.heaviside(
            t2 - self.ts_action, 0.0
        )
        return signal

    def get_baseline_smoothness(self):
        """Physics Specific Function"""
        signal = self.dummy_a3r_waveform()
        smoothed_signal = self.drive_smoother(signal)
        smoothness = self.calculate_smoothness(smoothed_signal)
        return smoothness

    def prepare_action(self, action):
        res_drive = self.a0 * action.astype(jnp.float64)  # Scale up Action
        normalizing_factor = jnp.clip(
            self.mu * self.a0 / jnp.absolute(res_drive),
            0.0,
            1.0,
        )
        res_drive *= normalizing_factor  # Clip Pulse Amplitude
        res_drive = self.drive_smoother(res_drive)  # Apply Smoother
        res_drive = self.bandwidth_constrainer(res_drive)  # Apply Bandwidth Constraints
        normalizing_factor = jnp.clip(
            self.mu * self.a0 / jnp.absolute(res_drive),
            0.0,
            1.0,
        )
        res_drive *= normalizing_factor  # Clip Pulse Amplitude
        return res_drive

    def bandwidth_constrainer(self, res_drive: chex.Array):
        """Physics Specific Function"""
        freqs = fftfreq(n=self.num_actions, d=self.ts_action[1] - self.ts_action[0])
        fft_action = fft(res_drive)
        bandwidth_constraint = jnp.heaviside(self.bandwidth - jnp.abs(freqs), 1.0)
        fft_action_transformed = fft_action * bandwidth_constraint

        action_transformed = ifft(fft_action_transformed)
        return action_transformed.real

    def step_env(
        self, key: chex.PRNGKey, state: EnvState, action: chex.Array, params: EnvParams
    ) -> Tuple[chex.Array, EnvState, chex.Array, bool, dict]:
        """
        IMPORTANT Perform Single Episode State Transition
        - key is for RNG, needs to be handled properly if used
        - state is the input state, will be modified to produce new state
        - action is an array corresponding to action space shape
        - params is the appropriate Env Params, this argument shouldn't change during training runs

        Returns Observation, New State, Reward, Dones Signal, and Info based on State
        In this particular task, the observation is always fixed, and the Dones is
        always True since its a single-step environment.
        """
        new_timestep = state.timestep + 1

        rng, _rng = jax.random.split(key)

        # Preparing Action for Simulation
        res_drive = self.prepare_action(action)

        # Simulation and Obtaining Reward + Params for New State
        single_result = self.calc_results(res_drive)
        reward, updated_state_array = self.calc_reward_and_state(
            _rng,
            single_result.astype(self.float_dtype),
            res_drive,
            res_drive / self.a0,
        )

        env_state = EnvState(*updated_state_array, action, new_timestep)

        done = True
        return (
            lax.stop_gradient(self.get_obs()),
            lax.stop_gradient(env_state),
            reward,
            done,
            lax.stop_gradient(self.get_info(env_state)),
        )

    def calculate_bandwidth(self, action):
        freqs = fftfreq(n=self.num_actions, d=self.ts_action[1] - self.ts_action[0])
        fft_action = fft(action)
        mag_fft_action = jnp.abs(fft_action)
        max_mag = jnp.max(mag_fft_action)

        freqs_shift = fftshift(freqs)
        mag_fft_action_shift = fftshift(mag_fft_action)
        bandwidth = jnp.abs(
            freqs_shift[
                jnp.where(
                    mag_fft_action_shift > self.freq_relative_cutoff * max_mag, size=1
                )[0][0]
            ]
        )

        return bandwidth

    def drive_smoother(self, res_drive: chex.Array):
        """Physics Specific Function"""
        conv_result = jnp.convolve(res_drive, self.kernel, mode="same")
        return conv_result

    def calculate_smoothness(self, action):
        """Physics Specific Function"""
        ts = self.ts_action
        dx = 1.0
        first_deriv = jnp.diff(action) / dx
        second_deriv = jnp.diff(first_deriv) / dx
        integral_val = trapezoid(y=second_deriv**2, x=ts[2:])
        return integral_val

    def get_bandwidth(self, batched_drive: chex.Array):
        """Physics Specific Function"""
        params = self.default_params
        fft_vals = jnp.fft.fft(batched_drive, axis=-1)
        fft_shifted = jnp.abs(jnp.fft.fftshift(fft_vals))

        indices = jnp.where(
            fft_shifted > params.bandwidth_threshold * jnp.max(fft_shifted),
            size=params.num_actions,
        )[0]
        min_index = indices[0]
        max_index = jnp.max(indices)
        bandwidth = jnp.array(
            [self.freqs_shifted[max_index] - self.freqs_shifted[min_index]],
            dtype=self.float_dtype,
        )
        return bandwidth

    def extract_values(
        self,
        key: chex.PRNGKey,
        results: chex.Array,
        processed_action: chex.Array,
        raw_action: chex.Array,
    ):
        """Physics Specific Function"""
        rng, _rng = jax.random.split(key)

        res_g = results[:, 0] + 1.0j * results[:, 1]
        res_e = results[:, 2] + 1.0j * results[:, 3]

        photon_g = jnp.abs(res_g) ** 2
        photon_e = jnp.abs(res_e) ** 2

        decay_g = -(self._gamma_I + self._photon_gamma * photon_g[1:].T) * self.dt
        decay_g = jnp.concatenate((jnp.ones(1), decay_g))
        # decay_g = jnp.vstack((jnp.ones(1), decay_g))
        decay_g = self._init_fid * jnp.cumsum(decay_g, axis=0).T

        photons_combined = jnp.concatenate(
            (photon_g.reshape(-1, 1), photon_e.reshape(-1, 1)), axis=-1
        )
        higher_photons = jnp.max(photons_combined, axis=-1)
        sep = jnp.abs(res_g - res_e)
        fidelity = 0.5 * (1.0 + erf(sep * self.scaling_factor)) * decay_g

        # Adding Gaussian Noise due to Measurement Shots
        rng, rng_fid = jax.random.split(rng)
        pi_fid = distrax.ClippedNormal(
            loc=fidelity, scale=self.shot_noise_std, minimum=0.0, maximum=fidelity
        )
        fidelity = pi_fid.sample(seed=rng_fid)

        pf = -jnp.log10(1.0 - fidelity)

        max_photons = jnp.max(higher_photons)
        min_photons_ind = jnp.argmin(higher_photons[self.ind :]) + self.ind
        min_photon_time = self.ts_sim[min_photons_ind]

        higher_photons += self.photon_limit * jnp.heaviside(
            self.ts_sim - min_photon_time, 0.0
        )
        closest_time_to_reset_ind = (
            jnp.argmin(
                jnp.abs(higher_photons[self.ind :] - self._ideal_photon), axis=-1
            )
            + self.ind
        )
        closest_time_to_reset_action_ind = (
            closest_time_to_reset_ind
            / (len(self.ts_sim) - 1)
            * (len(self.ts_action) - 1)
        )

        closest_time_to_reset_action_ind = closest_time_to_reset_action_ind.astype(
            jnp.int32
        )

        pulse_end_time = self.ts_sim[closest_time_to_reset_ind]
        pulse_reset_val = jnp.abs(
            processed_action[closest_time_to_reset_action_ind]
        ) + jnp.abs(processed_action[0])
        pulse_reset_val /= self.a0 * self.mu

        pulse_reset_photon = higher_photons[closest_time_to_reset_ind]
        photon_reset_time = pulse_end_time + self.photon_weight * self._tau * jnp.log(
            pulse_reset_photon / self._ideal_photon
        )
        photon_reset_time = jnp.clip(photon_reset_time, a_min=pulse_end_time)

        # TODO: Add shot noise to photon reset time
        rng, rng_time = jax.random.split(rng)
        pi_time = distrax.ClippedNormal(
            loc=self.standard_fid, scale=self.shot_noise_std, minimum=0.0, maximum=1.0
        )
        photon_reset_time = photon_reset_time * pi_time.sample(seed=rng_time)

        max_pf = jnp.max(pf)
        max_pf_time = self.ts_sim[jnp.argmax(pf)]

        smoothness = self.fast_smoothness_calc(raw_action / self.mu)
        bandwidth = self.calculate_bandwidth(self.a0 * raw_action)

        return (
            max_pf,
            max_photons,
            photon_reset_time,
            pulse_end_time,
            max_pf_time,
            smoothness,
            bandwidth,
            pf,
            higher_photons,
            pulse_reset_val,
        )

    def calc_results(
        self, res_drive: chex.Array
    ) -> Tuple[chex.Array, chex.Array, chex.Array, chex.Array, chex.Array]:
        """Physics Specific Function, Function used for ODE Simulation"""
        params = self.default_params
        control = LinearInterpolation(ts=self.ts_action, ys=res_drive)

        def vector_field(t, y, args):
            res_g_real, res_g_imag, res_e_real, res_e_imag = y
            drive_res = control.evaluate(t)
            kappa_half, chi, kerr = args

            res_g = res_g_real + 1.0j * res_g_imag
            res_e = res_e_real + 1.0j * res_e_imag

            d_res_g = (
                res_g
                * (
                    -kappa_half
                    - 0.5j * chi
                    + 1.0j * kerr * (res_g_real**2 + res_g_imag**2)
                )
                - 1.0j * drive_res
            )
            d_res_e = (
                res_e
                * (
                    -kappa_half
                    - 0.5j * chi
                    + 1.0j * chi
                    + 1.0j * kerr * (res_e_real**2 + res_e_imag**2)
                )
                - 1.0j * drive_res
            )

            return jnp.array(
                [d_res_g.real, d_res_g.imag, d_res_e.real, d_res_e.imag],
                dtype=jnp.float64,
            )

        ode_term = ODETerm(vector_field)

        sol = diffeqsolve(
            terms=ode_term,
            solver=params.solver,
            t0=0.0,
            t1=self._t1,
            dt0=params.dt0,
            y0=params.y0,
            args=params.args,
            saveat=self.saveat,
            stepsize_controller=self.stepsize_controller,
            max_steps=params.max_steps,
        )

        return sol.ys

    def precompile(self):
        """Function called on initialisation to jit + vmap the relevant functions"""
        self.batched_results = jit(vmap(self.calc_results, in_axes=0))
        self.batched_reward_and_state = jit(self.calc_reward_and_state)
        self.batched_smoother = jit(vmap(self.drive_smoother, in_axes=0))
        self.batched_extract_values = jit(self.extract_values)
        self.fast_smoothness_calc = jit(self.calculate_smoothness)

    def calc_reward_and_state(
        self,
        key: chex.PRNGKey,
        result: chex.Array,
        res_drive: chex.Array,
        action: chex.Array,
    ) -> Tuple[chex.Array, chex.Array]:
        """Function holding Reward Calculation and State Param Calculations"""
        rng, _rng = jax.random.split(key)
        (
            max_pf,
            max_photon,
            photon_reset_time,
            pulse_end_time,
            max_pf_time,
            smoothness,
            bandwidth,
            _,
            _,
            pulse_reset_val,
        ) = self.extract_values(_rng, result, res_drive, action)
        # The above function holds physics-specific details

        # Batched Reward is a function of:
        # 1. Max Negative Log Error During the Readout (use Absolute Values)
        # 2. Photon Reset Time
        # 3. Penalty Addition for max_photons (High RELU scaling)

        reward = (
            self.pf_reward(max_pf)
            + self.time_reward(photon_reset_time)
            + self.smoothness_reward(smoothness)
            + self.bandwidth_reward(bandwidth)
            + self.amp_reward(pulse_reset_val)
            - self.photon_pen(max_photon)
            - self.order_pen(pulse_end_time, max_pf_time)
        )

        state = jnp.array(
            [
                reward,
                max_pf,
                max_photon,
                photon_reset_time,
                smoothness,
                bandwidth,
                pulse_reset_val,
            ],
            dtype=jnp.float64,
        )

        return (reward, state)

    def pf_reward(self, max_pf):
        return self.pF_factor * max_pf

    def time_reward(self, photon_reset_time):
        return self.time_factor * (self._t1 - photon_reset_time) * self._kappa

    def smoothness_reward(self, smoothness):
        s_reward = -relu(
            smoothness / (self.smoothness_baseline_scale * self.baseline_smoothness)
            - 1.0
        )
        s_reward += 1.0 / (self.smoothness_baseline_scale * self.baseline_smoothness)
        return self.smoothness_factor * s_reward

    def bandwidth_reward(self, bandwidth):
        b_reward = relu(bandwidth / self.bandwidth - 1.0)
        return -self.bandwidth_factor * b_reward**2

    def photon_pen(self, max_photon):
        return self.photon_penalty * relu(max_photon / self.actual_max_photons - 1.0)

    def order_pen(self, pulse_end_time, max_pf_time):
        return self.order_penalty * (1.0 - jnp.sign(pulse_end_time - max_pf_time))

    def amp_reward(self, pulse_reset_val):
        return self.amp_penalty * (1.0 - pulse_reset_val)

    def rollout_action(
        self,
        key: chex.PRNGKey,
        action: chex.Array,
        time_below_photon_val: Optional[float] = 0.1,
        photon_log_scale: Optional[bool] = False,
        bound_plots: Optional[bool] = True,
    ):
        rng, _rng = jax.random.split(key)
        ts_sim = self.ts_sim
        ts_action = self.ts_action

        fig, ax = plt.subplots(3, figsize=(8.0, 16.0))

        # Obtaining Raw Action vs Smooth Action
        raw_action = action * self.a0
        normalizing_factor = jnp.clip(
            self.mu * self.a0 / jnp.absolute(raw_action),
            0.0,
            1.0,
        )
        raw_action *= normalizing_factor
        smooth_action = self.prepare_action(action)

        # Defining Default Gaussian Square Readout
        # Gaussian Edge with sigma and duration
        # Constant Amplitude for certain duration
        total_default_duration = self.tau_0
        dt = 0.00045
        gaussian_edge_sigma = 64 * dt
        gaussian_edge_duration = 2.0 * gaussian_edge_sigma
        gaussian_square_readout = self.a0 * jnp.heaviside(
            ts_action - gaussian_edge_duration, 0.0
        )
        gaussian_square_readout *= jnp.heaviside(
            total_default_duration - gaussian_edge_duration - ts_action, 1.0
        )
        gaussian_square_readout += (
            self.a0
            * jnp.exp(
                -((ts_action - gaussian_edge_duration) ** 2)
                / (2 * gaussian_edge_sigma**2)
            )
            * jnp.heaviside(gaussian_edge_duration - ts_action, 1.0)
        )
        gaussian_square_readout += (
            self.a0
            * jnp.exp(
                -((ts_action - (total_default_duration - gaussian_edge_duration)) ** 2)
                / (2 * gaussian_edge_sigma**2)
            )
            * jnp.heaviside(gaussian_edge_duration - ts_action, 1.0)
        )

        # Obtaining Results for Smooth Action and Gaussian Square
        rng, _rng = jax.random.split(rng)
        smooth_results = self.calc_results(smooth_action)
        (
            s_max_pf,
            s_max_photon,
            s_photon_reset_time,
            s_pulse_end_time,
            s_max_pf_time,
            s_smoothness,
            s_bandwidth,
            s_pF,
            s_higher_photons,
            s_pulse_reset_val,
        ) = self.extract_values(_rng, smooth_results, smooth_action, action)

        s_photon_reset_time = jnp.round(s_photon_reset_time, 3)
        s_pulse_end_time = jnp.round(s_pulse_end_time, 3)
        s_max_pf_time = jnp.round(s_max_pf_time, 3)

        rng, _rng = jax.random.split(rng)
        gaussian_results = self.calc_results(gaussian_square_readout)
        (
            g_max_pf,
            g_max_photon,
            g_photon_reset_time,
            g_pulse_end_time,
            g_max_pf_time,
            g_smoothness,
            g_bandwidth,
            g_pF,
            g_higher_photons,
            g_pulse_reset_val,
        ) = self.extract_values(
            _rng,
            gaussian_results,
            gaussian_square_readout,
            gaussian_square_readout / self.a0,
        )

        g_photon_reset_time = jnp.round(g_photon_reset_time, 3)
        g_pulse_end_time = jnp.round(g_pulse_end_time, 3)
        g_max_pf_time = jnp.round(g_max_pf_time, 3)

        smooth_g = smooth_results[:, 0] + 1.0j * smooth_results[:, 1]
        smooth_e = smooth_results[:, 2] + 1.0j * smooth_results[:, 3]
        gaussian_g = gaussian_results[:, 0] + 1.0j * gaussian_results[:, 1]
        gaussian_e = gaussian_results[:, 2] + 1.0j * gaussian_results[:, 3]

        s_higher_photons = jnp.abs(smooth_g) ** 2
        g_higher_photons = jnp.abs(gaussian_g) ** 2

        if bound_plots:
            ax[0].set_xlim(left=None, right=self._t1)
            ax[1].set_xlim(left=None, right=self._t1)
            ax[2].set_xlim(left=None, right=self._t1)

        ax[0].plot(ts_action, raw_action, label="Raw Action", alpha=0.5)
        ax[0].plot(ts_action, smooth_action, label="Smooth Action")
        ax[0].plot(ts_action, gaussian_square_readout, label="Default Gaussian Square")
        ax[0].axvline(
            x=s_max_pf_time,
            color="green",
            linestyle="dashed",
            label=f"Smooth Max pF Time: {s_max_pf_time}us",
        )
        ax[0].axvline(
            x=s_photon_reset_time,
            color="red",
            linestyle="dashed",
            label=f"Smooth Reset Time: {s_photon_reset_time}us",
        )
        ax[0].set_xlabel("Time (us)")
        ax[0].set_ylabel("Amp (A.U.)")
        ax[0].set_title("Pulse Waveforms")
        ax[0].legend()

        ax[1].plot(ts_sim, s_pF, label=f"Smooth pF max: {jnp.round(s_max_pf, 3)}")
        ax[1].plot(ts_sim, g_pF, label=f"Gaussian Square pF: {jnp.round(g_max_pf, 3)}")
        ax[1].axvline(
            x=s_max_pf_time,
            color="green",
            linestyle="dashed",
            label=f"Smooth Max pF Time: {s_max_pf_time}us",
        )
        ax[1].axvline(
            x=g_max_pf_time,
            color="purple",
            linestyle="dashed",
            label=f"Gaussian Max pF Time: {g_max_pf_time}us",
        )
        ax[1].axvline(
            x=s_photon_reset_time,
            color="red",
            linestyle="dashed",
            label=f"Smooth Reset Time: {s_photon_reset_time}us",
        )
        ax[1].set_xlabel("Time (us)")
        ax[1].set_ylabel("Negative Log Error (pF)")
        ax[1].set_title("pF vs Time")
        ax[1].legend()

        # Find first time 0.1 photons are reached right before reset
        s_photon_val_index = jnp.where(
            jnp.flip(s_higher_photons) > time_below_photon_val, size=1
        )[0][0]
        s_photon_val_time = jnp.round(ts_sim[-s_photon_val_index], 3)

        ax[2].plot(ts_sim, s_higher_photons, label="Smooth Photons")
        ax[2].plot(ts_sim, g_higher_photons, label="Gaussian Square Photons")
        ax[2].axvline(
            x=s_max_pf_time,
            color="green",
            linestyle="dashed",
            label=f"Smooth Max pF Time: {s_max_pf_time}us",
        )
        ax[2].axvline(
            x=g_max_pf_time,
            color="purple",
            linestyle="dashed",
            label=f"Gaussian Max pF Time: {g_max_pf_time}us",
        )
        ax[2].axvline(
            x=s_photon_val_time,
            color="orange",
            linestyle="dashed",
            label=f"Smooth Time to {time_below_photon_val} Photons: {s_photon_val_time}us",
        )
        ax[2].axvline(
            x=s_photon_reset_time,
            color="red",
            linestyle="dashed",
            label=f"Smooth Reset Time: {s_photon_reset_time}us",
        )
        ax[2].set_xlabel("Time (us)")
        ax[2].set_ylabel("Photons")
        ax[2].set_title("Photons vs Time")
        if photon_log_scale:
            ax[2].set_yscale("log")
        ax[2].set_ylim(bottom=1e-3)
        ax[2].legend()

        plt.figure(figsize=(8.0, 5.0))

        s_max_pf_index = jnp.argmin(jnp.abs(ts_sim - s_max_pf_time))
        g_max_pf_index = jnp.argmin(jnp.abs(ts_sim - g_max_pf_time))
        s_pulse_end_index = jnp.argmin(jnp.abs(ts_sim - s_pulse_end_time))

        plt.plot(smooth_g.real, smooth_g.imag, label="Smooth G")
        plt.plot(smooth_e.real, smooth_e.imag, label="Smooth E")
        plt.plot(gaussian_g.real, gaussian_g.imag, label="Gaussian G")
        plt.plot(gaussian_e.real, gaussian_e.imag, label="Gaussian E")
        plt.scatter(
            smooth_g[s_max_pf_index].real,
            smooth_g[s_max_pf_index].imag,
            label=f"Smooth G Max Pf time: {s_max_pf_time}us",
        )
        plt.scatter(
            smooth_e[s_max_pf_index].real,
            smooth_e[s_max_pf_index].imag,
            label=f"Smooth E Max Pf time: {s_max_pf_time}us",
        )
        plt.scatter(
            smooth_g[s_pulse_end_index].real,
            smooth_g[s_pulse_end_index].imag,
            label=f"Smooth G End time: {s_pulse_end_time}us",
        )
        plt.scatter(
            smooth_e[s_pulse_end_index].real,
            smooth_e[s_pulse_end_index].imag,
            label=f"Smooth E End time: {s_pulse_end_time}us",
        )
        plt.scatter(
            gaussian_g[g_max_pf_index].real,
            gaussian_g[g_max_pf_index].imag,
            label=f"Gaussian G Max Pf time: {g_max_pf_time}us",
        )
        plt.scatter(
            gaussian_e[g_max_pf_index].real,
            gaussian_e[g_max_pf_index].imag,
            label=f"Gaussian E Max Pf time: {g_max_pf_time}us",
        )
        plt.xlabel("I Quadrature (A.U.)")
        plt.ylabel("Q Quadrature (A.U.)")
        plt.title("IQ Phase Space Trajectories")
        plt.legend(bbox_to_anchor=(1.0, 1.0))

        plt.show()

    def reset_env(
        self, key: chex.PRNGKey, params: EnvParams
    ) -> Tuple[chex.Array, EnvState]:
        """IMPORTANT Reset Environment, in this case nothing needs to be done
        so default obs and info are returned"""
        # self.precompile()
        state = EnvState(
            reward=0.0,
            max_pf=0.0,
            max_photon=0.0,
            photon_time=0.0,
            smoothness=0.0,
            bandwidth=0.0,
            pulse_reset_val=0.0,
            action=jnp.zeros_like(self.ts_action),
            timestep=0,
        )
        return self.get_obs(params), state

    def get_obs(self, params: Optional[EnvParams] = EnvParams) -> chex.Array:
        """IMPORTANT Function to get observation at a given state, as this is a single-step
        episode environment, the observation can be left fixed"""
        return jnp.zeros((1,), dtype=jnp.float64)

    def get_info(self, env_state: EnvState) -> dict:
        """IMPORTANT Function to get info for a given input state"""
        return {
            "reward": env_state.reward,
            "max pF": env_state.max_pf,
            "max photon": env_state.max_photon,
            "photon time": env_state.photon_time,
            "smoothness": env_state.smoothness,
            "bandwidth": env_state.bandwidth,
            "pulse reset val": env_state.pulse_reset_val,
            "action": env_state.action,
            "timestep": env_state.timestep,
        }

    @property
    def name(self) -> str:
        """IMPORTANT name of environment"""
        return "ResonatorReadoutEnv"

    @property
    def num_actions(self, params: Optional[EnvParams] = EnvParams) -> int:
        """IMPORTANT number of actions"""
        return params.num_actions

    def action_space(self, params: Optional[EnvParams] = None) -> spaces.Box:
        """IMPORTANT action space shape"""
        if params is None:
            params = self.default_params

        return spaces.Box(
            low=params.min_action,
            high=params.max_action,
            shape=(params.num_actions,),
            dtype=jnp.float64,
        )

    def observation_space(self, params: Optional[EnvParams] = None) -> spaces.Box:
        """IMPORTANT observation space shape"""
        return spaces.Box(-1.0, 1.0, shape=(1,), dtype=jnp.float64)

    def state_space(self, params: EnvParams) -> spaces.Dict:
        """IMPORTANT state space shape"""
        low = jnp.array(
            [
                params.min_reward,
                params.min_separation,
                params.min_photon,
                params.min_reward,
                params.min_separation,
                params.min_photon,
                params.min_smoothness,
                params.min_bandwidth,
                params.t0,
                0.0,
            ],
            dtype=jnp.float64,
        )
        high = jnp.array(
            [
                params.max_reward,
                params.max_separation,
                params.max_photon,
                params.max_reward,
                params.max_separation,
                params.max_photon,
                params.max_smoothness,
                params.max_bandwidth,
                self._t1,
                1.0,
            ],
            dtype=jnp.float64,
        )
        return spaces.Dict(
            {
                "mean batch reward": spaces.Box(low[0], high[0], (), dtype=jnp.float64),
                "mean batch separation": spaces.Box(
                    low[1], high[1], (), dtype=jnp.float64
                ),
                "mean batch photon": spaces.Box(low[2], high[2], (), dtype=jnp.float64),
                "max batch reward": spaces.Box(low[3], high[3], (), dtype=jnp.float64),
                "separation at max": spaces.Box(low[4], high[4], (), dtype=jnp.float64),
                "photon at max": spaces.Box(low[5], high[5], (), dtype=jnp.float64),
                "bandwidth at max": spaces.Box(low[6], high[6], (), dtype=jnp.float64),
                "smoothness at max": spaces.Box(low[7], high[7], (), dtype=jnp.float64),
                "time of max": spaces.Box(low[8], high[8], (), dtype=jnp.float64),
                "index of max": spaces.Box(low[9], high[9], (), dtype=jnp.float64),
            }
        )
